#### TERRAFORM-ECS-APP (TEA)


The resulting code programmatically provisions and launches a web-application into the AWS cloud using Docker, ECS (Elastic Container Service) and EC2 (Elastic Computing).

Basically it’s a minimal implementation of Infrastructure as Code to see an app live on the web.  If you would like a better understanding of the code, a guided tour is available as a [medium article](https://advancingship.medium.com/from-concept-to-cloud-app-a-reusable-docker-terraform-and-aws-elastic-container-service-119328250945)

##### Project Structure

###### front-end
A front-end web-app - This contains the same operational but featureless app generated by the 'npx create-react-app front-end' command. You can extend or replace it

###### cloud/prod/services/front-end
The Infrastructure As Code needed for -
* Provisioning the docker image
* Launching to AWS cloud
* Running the app

###### cloud/test/ 
The Code needed for -
* Testing the app
* Testing the Docker Image


##### Optional Customization
###### To extend the front-end app
Add features to the front-end app in /front-end.
###### To use with your own React-App:
You can replace the /front-end directory with your own app directory. You may have to edit the line, ‘"source": "../../../../front-end’, in build.json to reflect the name of that app directory.

##### To use an app other than React
Replace the shell commands for installing libraries, nvm, node, npm and npx in the provisioners block in cloud/prod/services/front-end/build.json with commands to install the libraries, languages and frameworks of your choosing

The user and app directory in the docker image are named "project-name" but you can rename them as long as the change is made consistent across:
* cloud/prod/services/front-end/build.json and 
* cloud/prod/services/front-end/user-data.sh 
* cloud/test/goss.yaml

##### Key
Text book-ended with stars such as 
 
   \*text-here*  

indicates that you should replace the stars and text with the appropriate value.

##### Requirements:
In order to run this project, the third party tools in the list that follows must be installed.  Version numbers indicate what versions were used in final testing.

* Terraform - v0.12.19 
* goss - v0.3.10 
* packer - 1.5.4 
* docker - 19.03.13, build 4484c46d9d 
* python - 3.7.4 for pip 
* pip - 20.1.1 (to install AWS CLI)
* an AWS account - The account itself is free, but AWS may charge you for usage.
* AWS CLI - aws-cli/1.18.102 Python/3.7.4 Linux/5.4.0-51-generic botocore/1.17.25 

##### AWS Setup:
You need to set up access credentials to have programmatic access to AWS

This project requires the following credential access info
* An AWS access key - https://docs.aws.amazon.com/general/latest/gr/aws-security-credentials.html 
* An EC2 key pair - https://docs.aws.amazon.com/cli/latest/userguide/cli-services-ec2-keypairs.html#creating-a-key-pair

##### Home Environment and Environmental Variables
Set up the following environment variables on your machine. They are needed in order to run the terraform operations 

the project directory in the docker image 
* TF_VAR_PROJECT_1_WORKING_DIRECTORY=/home/project-name/services/front-end

the AWS access key ID 

* AWS_ACCESS_KEY_ID=\*access-key-id*

the AWS secret access key
* AWS_SECRET_ACCESS_KEY=\*secret-access-key*

the EC2 key pair name 
* TF_VAR_PROJECT_1_KEY_NAME=\*key-name* (if your key is “key-name.pem”, use “key-name”)

The URI for the image in the image repository (You don’t need to set this up until you’re ready to push your image to AWS ECR, Docker Hub, other)
* TF_VAR_PROJECT_1_IMAGE_URI=\*repository-url*:*tag*

The AWS region (us-east-1 is the project default, but you can opt to change it.)
* TF_VAR_PROJECT_1_AWS_REGION_1=us-east-1

The name of the project (project-name is the project default, but you can opt to change it. 
Just make sure you replace all instances in the project code.)
* TF_VAR_PROJECT_1_NAME=project-name


##### Installation
Run these shell commands on home environment

Clone the project into the directory of your choice 

    git clone https://github.com/advancingship/terraform-ecs-app.git
  
Go to the front-end directory under cloud

    cd project-name/cloud/prod/services/front-end/

Build the image with packer

    packer build build.json

Import the image with docker

    docker import image.tar

Run the following command to list the latest image. Copy the latest image ID from the output. Use 'sec' if imported less than a minute ago, 'min' if under an hour, etc. 

    docker images | grep sec
  
##### Test or use the image 
Run these shell commands on your home environment or on a shell in the EC2 instance.  Skip the docker commands when in the container

Run a bash shell on the container 

    docker run -it *image-id* bash

In the shell, go to the project directory 

    cd /home/project-name/services/front-end/
  
Run the web-app tests. You can exit by typing 'q' 

    npm test

Run the project. You can exit with ctrl-c

    npm start
  
Exit the container
   
    exit
  
If you want to be able to view your running app from localhost, you may have to map the container’s port to the port on your machine.  For example, for a ReactApp which runs on port 3000, you could add the docker port mapping flag to the npm start command:

    docker run -p 3000:3000 7c33d8966d95 /bin/bash -c "cd /home/project-name/services/front-end/; npm start”

##### Tag and push the image to an image repository
Run these shell commands on your home environment.  When you know the URL of your image repository, remember to set the TF_VAR_PROJECT_1_IMAGE_URI environmental variable.

    docker tag *image-id* *repository-url*

Your repository URL can depend on how you tag your image and the repository you use.  Generally speaking,  docker tags identify the image.  

This is an example using Docker Hub

    docker tag 7c33d8966d95 *mydockeraccount*/terraform-ecs-app:1.0   

This is an example using AWS ECR

    docker tag 7c33d8966d95 000123456789.dkr.ecr.us-east-1.amazonaws.com/repo-name:latest

If you are using AWS ECR and the above command returns a request to re-authenticate, you can do so by running the command below and then re-running the tag command.

    aws ecr get-login-password --region *region-such-as-us-east-1* | docker login --username *user-name-such-as-AWS* --password-stdin *repository-url*

If run into problems with the AWS CLI, It may need to be updated. If you used pip the following should do it:
   
    pip install --upgrade awscli
  
Next, push the image to the repository

    docker push *repository-url*
  
##### Test and run Terraform (AWS may apply usage charges)
Run these commands on a shell in your home environment

Navigate to the cloud/test directory

Test the terraform operations.

    go test -v aws_ecs_terra_test.go
  
Navigate to the cloud/prod/services/front-end directory

Output a list of operations that terraform will execute. I have often found it helpful. 

    terraform plan
  
Dismantle any previously launched infrastructure. Type ‘yes’ when prompted. 

    terraform destroy

Launch your infrastructure. Type ‘yes’ when prompted 

    terraform apply

##### Get the URL and View the Live App

 you can use the AWS console on the web to find the url for your instance.  First ensure the region in the upper right of the console is consistent with the default or specified region used by TEA.  Then you can navigate to the EC2 page and look at your instances. Click on the line of the launched instance and the details will be shown below, including the public URL of that machine. Copy that to your browser and, given 3–6 minutes after launch, you should see the default react app page.  Now you can add some features to the app!
